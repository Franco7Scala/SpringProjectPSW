"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const MultiModuleFactory = require("webpack/lib/MultiModuleFactory");
const SingleEntryDependency = require("webpack/lib/dependencies/SingleEntryDependency");
const babel_target_entry_plugin_1 = require("./babel.target.entry.plugin");
const babel_target_multi_entry_dependency_1 = require("./babel.target.multi.entry.dependency");
const babel_target_single_entry_dependency_1 = require("./babel.target.single.entry.dependency");
class BabelTargetMultiEntryPlugin extends babel_target_entry_plugin_1.BabelTargetEntryPlugin {
    constructor(targets, context, name, entries) {
        super(targets, context, name);
        this.entries = entries;
    }
    apply(compiler) {
        super.apply(compiler);
        compiler.hooks.compilation.tap('BabelTargetMultiEntryPlugin', (compilation, { multiModuleFactory, normalModuleFactory }) => {
            compilation.dependencyFactories.set(babel_target_multi_entry_dependency_1.BabelTargetMultiEntryDependency, multiModuleFactory || new MultiModuleFactory());
            compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
        });
        compiler.hooks.make.tapPromise('BabelTargetMultiEntryPlugin', (compilation) => __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.targets.map((target) => __awaiter(this, void 0, void 0, function* () {
                const entries = [...(target.additionalModules || []), ...this.entries];
                const dep = BabelTargetMultiEntryPlugin.createDependency(target, entries, this.name);
                return yield this.addEntry(compilation, dep);
            })));
        }));
    }
    static createDependency(target, entries, name) {
        return new babel_target_multi_entry_dependency_1.BabelTargetMultiEntryDependency(target, entries.map((e, idx) => {
            // Because entrypoints are not dependencies found in an
            // existing module, we give it a synthetic id
            return new babel_target_single_entry_dependency_1.BabelTargetSingleEntryDependency(target, e, name, { name, index: idx });
        }), name);
    }
}
exports.BabelTargetMultiEntryPlugin = BabelTargetMultiEntryPlugin;
//# sourceMappingURL=babel.target.multi.entry.plugin.js.map