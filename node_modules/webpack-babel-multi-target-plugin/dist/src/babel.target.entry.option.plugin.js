"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const babel_target_multi_entry_plugin_1 = require("./babel.target.multi.entry.plugin");
const babel_target_single_entry_plugin_1 = require("./babel.target.single.entry.plugin");
// takes over processing of webpack's entry options so that it generates one entry per entry and target
// basically the same as webpack's built-in EntryOptionPlugin, just using the babel targeting stuff instead
/**
 * @internalapi
 */
class BabelTargetEntryOptionPlugin {
    constructor(targets) {
        this.targets = targets;
    }
    itemToPlugin(context, item, name) {
        if (Array.isArray(item)) {
            return new babel_target_multi_entry_plugin_1.BabelTargetMultiEntryPlugin(this.targets, context, name, item);
        }
        if (this.targets.find(target => !!(target.additionalModules && target.additionalModules.length))) {
            return new babel_target_multi_entry_plugin_1.BabelTargetMultiEntryPlugin(this.targets, context, name, [item]);
        }
        return new babel_target_single_entry_plugin_1.BabelTargetSingleEntryPlugin(this.targets, context, name, item);
    }
    apply(compiler) {
        compiler.hooks.entryOption.tap('EntryOptionPlugin', (context, entry) => {
            if (typeof entry === 'string' || Array.isArray(entry)) {
                this.itemToPlugin(context, entry, 'main').apply(compiler);
            }
            else if (typeof entry === 'object') {
                for (const name of Object.keys(entry)) {
                    this.itemToPlugin(context, entry[name], name).apply(compiler);
                }
            }
            else if (typeof entry === 'function') {
                throw new Error('not supported');
                // new DynamicEntryPlugin(context, entry).apply(compiler)
            }
            return true;
        });
    }
}
exports.BabelTargetEntryOptionPlugin = BabelTargetEntryOptionPlugin;
//# sourceMappingURL=babel.target.entry.option.plugin.js.map